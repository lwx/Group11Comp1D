module adder ( //performs addition, subtration, multiplication, modulo functions
//inputs from the ALU
    input alufn[1],
    input a[8],  
    input b[8],  
//outputs to the ALU   
    output sum1[8],
    output z[1],
    output v[1],
    output n[1],
    output overadd //to show addition overflow
   
  ) {
  
sig sum[9]; //9-bit output
sig ssum[9]; //subtraction sum used to calculate z,v,n
sig newsum[9];
  
  always {
    
    case(alufn[0]){ //alufn value controlling add or subtract operator
    
    b0:
      ssum = a-b;
      newsum = alufn^b;// need to do the always XOR b operation
      sum = a+b; //addition
    b1:
      newsum = alufn^b;
      sum = a-b; //subtraction

    default:
      newsum = alufn^b;
      sum = a+b;
  }
    //assigning values to outputs
    sum1=sum[7:0];
    ssum = ssum;//So that's what you mean by written
    //v = (a[7] & ~b[7] & (~ssum[7])) | ((~a[7])&(b[7])&ssum[7]);
    //overadd = (a[7] & b[7] & (~sum[7])) | ((~a[7])&(~b[7])&sum[7]);
    //n = ssum[7];
    //z = ~|ssum;
    v = (a[7] & b[7] & (~newsum[7])) | ((~a[7])&(~b[7])&newsum[7]);
    
    overadd = (a[7] & b[7] & (~sum[7])) | ((~a[7])&(~b[7])&sum[7]);
    n = newsum[7];
    z = ~|newsum;// Not too sure 
    

}
}
